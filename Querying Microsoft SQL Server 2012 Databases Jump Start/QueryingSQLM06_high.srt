1
00:00:00,333 --> 00:00:06,333
[Music]

2
00:00:18,483 --> 00:00:20,466
>> Okay. Welcome back. Tobias and I want to thank

3
00:00:20,333 --> 00:00:23,466
you for spending some time with us today, and we want to continue

4
00:00:23,483 --> 00:00:26,466
our discussion on querying, but I'm going to use that term loosely

5
00:00:26,483 --> 00:00:30,466
for this module in SQL Server 2012. We've been talking about,

6
00:00:30,483 --> 00:00:34,466
for five modules now, the idea of querying content. We're going

7
00:00:34,483 --> 00:00:39,466
to kind of shift a little bit to talking a little bit about inserting

8
00:00:39,483 --> 00:00:42,466
and updating data and how we can kind of protect that data as

9
00:00:42,483 --> 00:00:45,166
we're inserting and updating that data. So we're going to look

10
00:00:45,483 --> 00:00:48,466
here, inserts, updates, deletes. We're going to talk about the

11
00:00:48,483 --> 00:00:52,466
use of defaults, constraints, and triggers. So one of the big

12
00:00:52,200 --> 00:00:54,466
things that we want is we want to make sure that we're retrieving

13
00:00:54,483 --> 00:00:57,466
content, and we've talked about several modules of how we're

14
00:00:57,483 --> 00:01:00,383
going to do that, but we want to make sure we're adding content

15
00:01:00,466 --> 00:01:03,466
that we understand that the old G/L, garbage in/garbage out.

16
00:01:03,483 --> 00:01:06,466
So if you don't have things like constraints and we don't have

17
00:01:06,483 --> 00:01:11,466
data integrity procedures in place, that when we retrieve content,

18
00:01:11,483 --> 00:01:13,466
it may not be valid content. So we're going to look at ways for

19
00:01:13,483 --> 00:01:16,466
inserting, updating, deleting content, validating that content

20
00:01:16,483 --> 00:01:19,466
the best we can to make sure we've got good content that's going

21
00:01:19,483 --> 00:01:22,466
in, so we do perform some of these tasks that we've been talking

22
00:01:22,483 --> 00:01:25,333
about in the previous modules. We've got good stuff coming back

23
00:01:25,483 --> 00:01:27,466
out, not garbage like we're so... like we had talked about.

24
00:01:27,483 --> 00:01:30,333
So we want to avoid the garbage in/garbage out. We're going

25
00:01:30,483 --> 00:01:33,416
to take a look at in this module here. What we've been talking

26
00:01:33,483 --> 00:01:36,466
about are DD... DML statements. This should be DML, as well.

27
00:01:36,483 --> 00:01:39,466
Let me see what this is. Yeah, this should be DML statements.

28
00:01:39,483 --> 00:01:42,466
DML statements are data manipulation statements. So querying,

29
00:01:42,483 --> 00:01:46,466
using a select team, it's a DML. This is also a DML. We're going

30
00:01:46,483 --> 00:01:49,283
to talk about inserts and updates and deletes. DDL are statements

31
00:01:49,366 --> 00:01:52,466
where we create objects or modify objects or alter objects.

32
00:01:52,483 --> 00:01:56,466
So this should be DML instead of DDL, but we're going to talk

33
00:01:56,483 --> 00:01:59,466
about DML statements, continue to talk about DML statements because

34
00:01:59,483 --> 00:02:02,466
a select statement is a DML, as well. So let's take a look at

35
00:02:02,483 --> 00:02:05,466
how we get content in there. So again, one of our concerns is

36
00:02:05,483 --> 00:02:08,333
we want to avoid the garbage in, the garbage out, so we're going

37
00:02:08,416 --> 00:02:10,466
to look at ways we can to do that. Now, we're going to add content.

38
00:02:10,483 --> 00:02:13,466
This is a pretty straightforward insert into statement.

39
00:02:14,216 --> 00:02:16,466
We're going to insert it into Production.UnitMeasure.

40
00:02:17,416 --> 00:02:19,366
If we don't know the name of the columns or we don't want to

41
00:02:19,450 --> 00:02:22,466
supply the name... or the values in any certain orders, we supply

42
00:02:22,483 --> 00:02:25,466
the column names. So if we looked at the unit measure, there's

43
00:02:25,483 --> 00:02:28,466
name, there's unit measure code, there's modified date. If I

44
00:02:28,483 --> 00:02:32,466
did a select asterisk from unit measure, it's actually unit measure

45
00:02:32,166 --> 00:02:35,466
code, then name, and modify date. That's actually how it's stored

46
00:02:35,483 --> 00:02:39,466
in the content. But if we want to apply values to the columns,

47
00:02:39,483 --> 00:02:42,466
they don't have to be in any certain order, as long as we include

48
00:02:42,483 --> 00:02:45,466
the column headers. That's what we've done in the top example

49
00:02:45,183 --> 00:02:48,466
right here. Now, another way we can add content is insert into.

50
00:02:48,483 --> 00:02:51,466
So this is inserting just a basic row. And notice what we're

51
00:02:51,483 --> 00:02:55,466
doing here. We're adding a value in the name column called square

52
00:02:55,483 --> 00:03:00,166
yards and the unit measure code is Y2, and the modified date,

53
00:03:00,250 --> 00:03:02,466
we're actually going to going to be retrieving the system date.

54
00:03:02,483 --> 00:03:06,466
We could hard code a date in there, but we're actually retrieving

55
00:03:06,483 --> 00:03:09,466
the system date. This is adding just a single row. We can add

56
00:03:10,483 --> 00:03:13,466
multiple rows using a similar statement, but under values what

57
00:03:13,483 --> 00:03:15,466
we're going to do is we're going to add multiple occurrences

58
00:03:15,483 --> 00:03:18,466
of the value. Now we're adding square feet and square inches

59
00:03:18,483 --> 00:03:23,466
and we're going to use F2 and I2 for inches. So this is the

60
00:03:23,483 --> 00:03:27,466
squaring of those types of measurements here. So that's how

61
00:03:27,483 --> 00:03:29,466
we can insert some of the data.

62
00:03:29,483 --> 00:03:33,466
We can also use what's called an insert into the content, but

63
00:03:33,483 --> 00:03:37,333
now instead of supplying the values, we're going to use the select statement.

64
00:03:37,416 --> 00:03:40,466
So instead of insert select option, and what we're going to do

65
00:03:40,483 --> 00:03:43,466
to populate this name and unit measure code and modify date,

66
00:03:43,483 --> 00:03:46,466
we're going to select name, unit measure, code and modified date

67
00:03:46,483 --> 00:03:49,466
from, we'll say, a temporary unit table that was... that exists

68
00:03:49,483 --> 00:03:52,466
out there. So we're going to take the content using a select

69
00:03:52,483 --> 00:03:57,200
statement and we're going to populate that into the unit measure

70
00:03:57,283 --> 00:04:01,466
content table. Excuse me. And we don't have to grab everything.

71
00:04:02,166 --> 00:04:04,466
Because we're using a select statement, we could say we only

72
00:04:04,483 --> 00:04:08,466
want to insert the content from January 1st, 2008. The good

73
00:04:08,483 --> 00:04:12,333
news about this class is I'm going to learn to understand these

74
00:04:12,483 --> 00:04:15,466
time stamps in reverse order. That's my goal. So this is January

75
00:04:15,483 --> 00:04:19,466
1st, 2008, and we're going to only add content that's less than that.

76
00:04:20,483 --> 00:04:22,466
Anything older than that, we're not going to add that content.

77
00:04:22,483 --> 00:04:26,166
So we still have control of what content gets added. The insert

78
00:04:26,483 --> 00:04:29,466
into the execute statement, we're going to insert into these

79
00:04:29,483 --> 00:04:32,466
three columns again, but this time, instead, we're going to execute

80
00:04:32,483 --> 00:04:35,300
a store procedure and we're going to pass at some variables,

81
00:04:35,383 --> 00:04:38,466
the numbers row five and the category ID of 1, and that's going

82
00:04:38,483 --> 00:04:42,466
to execute our only insert content into this table that meets

83
00:04:42,483 --> 00:04:46,466
the only five rows as long as category ID is equal to one.

84
00:04:46,483 --> 00:04:50,466
So again, we're controlling what content that we're adding into

85
00:04:50,483 --> 00:04:52,466
the tables, and that's a big deal, to make sure that we're not

86
00:04:53,333 --> 00:04:57,416
adding that garbage in. We're going to also perform a select into.

87
00:04:57,483 --> 00:04:59,466
Again, we're going to do a select name unit measure code and

88
00:05:00,333 --> 00:05:05,200
modify date into. So now we're taking content into a temporary table.

89
00:05:05,283 --> 00:05:08,466
So back a slide or two before I wanted to use a temporary table.

90
00:05:08,483 --> 00:05:11,383
I could have created the temporary table from content that's

91
00:05:11,466 --> 00:05:14,466
inside the unit measure table. I could do a select name and unit

92
00:05:14,483 --> 00:05:18,466
measure code and modify date, which are columns within the unit

93
00:05:18,483 --> 00:05:21,466
measure table right here, and I'm going to select them and insert

94
00:05:21,483 --> 00:05:25,466
them into a new table called temp UOM table. And again, I'm

95
00:05:25,483 --> 00:05:28,466
going to be specific about what contents ordered in there, are

96
00:05:28,483 --> 00:05:31,466
populated in there because I'm going to put where order date

97
00:05:33,483 --> 00:05:37,466
is before January 1st of 2008. So again, controlling what I'm

98
00:05:37,483 --> 00:05:41,0
doing when I'm adding content in there. Now, one of the things

99
00:05:41,483 --> 00:05:44,466
we may want to do is create what's called an identity column.

100
00:05:44,483 --> 00:05:47,466
An identity column allows me to create a column that I don't

101
00:05:47,483 --> 00:05:52,466
need to populate myself. I decide what items or what numbers

102
00:05:52,483 --> 00:05:55,466
I want in there. So what I do is I created integer value. I think

103
00:05:55,483 --> 00:05:59,466
we've got here... yeah, we've got product ID and identity, and

104
00:05:59,483 --> 00:06:03,466
then we identify what's called the seed in the increment value.

105
00:06:03,483 --> 00:06:06,466
By default it's one and one. So if I don't specify that, it's

106
00:06:06,483 --> 00:06:09,466
one and one. So the very first row I insert is going to get product

107
00:06:09,483 --> 00:06:12,466
ID number one. The second row is going to get number two.

108
00:06:12,483 --> 00:06:15,183
The third row is going to get number three. And the US where

109
00:06:15,266 --> 00:06:18,466
they use Fahrenheit or Celsius, the next row is going to be number four.

110
00:06:18,216 --> 00:06:20,466
It doesn't really matter. But what you would you do differently

111
00:06:20,483 --> 00:06:25,316
here is we can say we want the seed to start at 100 instead of

112
00:06:25,400 --> 00:06:28,466
one, and instead of incrementing by one, we're going to increment

113
00:06:28,483 --> 00:06:33,466
by ten. First row will be 100, then 110, then 120, then 130.

114
00:06:33,483 --> 00:06:36,466
And then it's going to populate that information automatically

115
00:06:36,483 --> 00:06:40,466
for me instead of me having to supply that identity column.

116
00:06:40,483 --> 00:06:43,466
So it's a way for us to automatically generate a number and have

117
00:06:43,483 --> 00:06:47,466
that number populated for me with me defining the increment value

118
00:06:47,483 --> 00:06:50,466
and that seed value where I start with. Now, this is set up

119
00:06:50,483 --> 00:06:54,466
on a table level. Another option is the sequences option.

120
00:06:54,483 --> 00:06:58,466
This is new in SQL Server 2012. This allows me to create it for

121
00:06:58,483 --> 00:07:02,416
the database, so this is going to create sequence called invoice

122
00:07:02,483 --> 00:07:05,466
sequence as an integer, and here's my seed value. It starts

123
00:07:05,483 --> 00:07:09,466
with five, and here's my increment value start with five or increment

124
00:07:09,483 --> 00:07:13,466
by five. Excuse me. So wherever I use this invoice.suq, it's

125
00:07:13,483 --> 00:07:17,466
going to start, the first row is going to be added as 5, the

126
00:07:17,483 --> 00:07:21,366
next row will be ten, 15, 20, et cetera. And then if I want

127
00:07:21,450 --> 00:07:24,466
to retrieve information and what's the last number that was used?

128
00:07:24,483 --> 00:07:29,433
I can select next value for DBO.invoice sequence. So the last

129
00:07:29,483 --> 00:07:33,466
number used was 25, the next value would be 30. If I'm quick

130
00:07:33,233 --> 00:07:37,466
with math, I can do 25... 30 minus five is the 25. So this would

131
00:07:37,483 --> 00:07:39,466
retrieve what the next value is going to be used that's going

132
00:07:39,483 --> 00:07:43,466
to be populated using this sequences option, which, again, new

133
00:07:43,483 --> 00:07:47,183
to 2012 and set up more instead of a table level like the identity,

134
00:07:47,266 --> 00:07:49,466
it's set up at the database level.

135
00:07:50,483 --> 00:07:53,416
Now, ways for us to modify content. We might store content in

136
00:07:53,483 --> 00:07:55,466
SQL Server and realize, oops, I shouldn't have done it that way

137
00:07:55,483 --> 00:07:59,283
or I need to change that. We have the update statement, all right?

138
00:07:59,366 --> 00:08:02,333
Now, we're going to be careful about this. Update Production.UnitMeasure,

139
00:08:02,483 --> 00:08:06,466
set modify date equal get the date... get date. Now, if I stopped

140
00:08:06,483 --> 00:08:10,466
right there and just executed this statement, what have I just done?

141
00:08:11,366 --> 00:08:16,233
I've actually updated every row in the unit measure column, table

142
00:08:16,483 --> 00:08:20,466
to set the modify date to today's date. What I need to do is,

143
00:08:20,483 --> 00:08:24,350
specifically be more careful about is making sure we supply a

144
00:08:24,433 --> 00:08:27,466
where clause where unit measure code equal M2. Now it's going

145
00:08:27,483 --> 00:08:32,466
to only go to that M2, to square miles row, and it's going to

146
00:08:32,483 --> 00:08:37,466
set the modify date to today's date because we're using the system

147
00:08:37,166 --> 00:08:41,216
value here, function to get today's date and populate that.

148
00:08:41,300 --> 00:08:43,466
Again, be very cautious when you're doing update to make sure

149
00:08:43,483 --> 00:08:47,466
you supply a where clause, unless you want every row to be updated.

150
00:08:48,350 --> 00:08:51,466
Very similar to that, we have something, another way we can modify

151
00:08:51,483 --> 00:08:54,466
date is called the merge. Now, this is where I can use a merge

152
00:08:54,483 --> 00:08:58,466
to modify database on any of the following conditions.

153
00:08:58,483 --> 00:09:01,466
Source matches the target, source has no match in a target, or

154
00:09:02,483 --> 00:09:04,300
when the target has no match in a source. So this is a nice

155
00:09:04,383 --> 00:09:08,466
way for us to be able to update content within a database.

156
00:09:09,483 --> 00:09:16,300
>> Yes, I thought we'd do a bit of demo, just look at merge, and

157
00:09:16,383 --> 00:09:20,183
we'll do somewhat of a stray thing to just show a bit of the

158
00:09:20,266 --> 00:09:23,466
XML functionality we have as well in the product, because it

159
00:09:23,483 --> 00:09:27,466
kind of fits nicely in this particular topic. So bear with me

160
00:09:27,483 --> 00:09:30,466
a little bit so we get kind of an interesting example going.

161
00:09:30,483 --> 00:09:32,466
>> We swapped out his keyboard, by the way, because the other

162
00:09:32,483 --> 00:09:38,433
one burnt out, so he should be good to go for a little while.

163
00:09:38,450 --> 00:09:38,466
>> Thank you, Brian.

164
00:09:39,483 --> 00:09:40,466
>> Do you have carpal tunnel or anything, dude? I don't think

165
00:09:40,483 --> 00:09:43,466
you have time for carpal tunnel. I think your nerves don't even...

166
00:09:44,483 --> 00:09:49,316
>> Okay. So let's say that what I want to do is I want to retrieve

167
00:09:49,400 --> 00:09:52,466
products in XML format. Then later I want to be able to grab

168
00:09:52,483 --> 00:09:57,166
that XML being passed from the client and actually update a set

169
00:09:57,250 --> 00:10:01,466
of products, update or insert a set of products based on this

170
00:10:01,483 --> 00:10:05,250
XML definition. So I'll start with just simplifying the table

171
00:10:05,333 --> 00:10:08,466
a little bit so it's not so complicated for me to just perform

172
00:10:08,483 --> 00:10:11,466
the insert because it's so many columns in here. So I'll just

173
00:10:11,483 --> 00:10:15,466
grab product ID, and let's say, name and that's going to be enough

174
00:10:15,483 --> 00:10:20,466
for me. And I'll use this into keyword, and just to be clear,

175
00:10:20,483 --> 00:10:24,466
earlier we had examples where the tables were called temp something.

176
00:10:24,483 --> 00:10:28,466
They weren't necessarily temp tables, which is something differently,

177
00:10:28,483 --> 00:10:34,466
or something different. So I'll just call this table just products.

178
00:10:36,333 --> 00:10:38,466
So I'm just dealing these two columns and putting them in this table.

179
00:10:39,483 --> 00:10:44,466
Now let's start by grabbing this ask XML. So I want to grab

180
00:10:44,483 --> 00:10:47,466
all columns or all products, rather,

181
00:10:48,483 --> 00:10:54,466
where the name starts with an A, let's say, as a filter. Okay.

182
00:10:54,483 --> 00:10:55,466
Good. Three of them.

183
00:10:56,366 --> 00:11:00,433
And I would like this again returned as XML, so I'll say for

184
00:11:00,483 --> 00:11:04,466
XML, and the best... what you typically use is for XML path.

185
00:11:04,483 --> 00:11:08,466
There's for XML row out to explicit and path, but path is the

186
00:11:08,483 --> 00:11:09,466
more powerful one.

187
00:11:11,166 --> 00:11:13,466
Now, why would you like to return anything as XML? It turns out

188
00:11:13,483 --> 00:11:18,466
it's very practical format for interchange between systems.

189
00:11:18,483 --> 00:11:21,466
So if you want to pass a set from SQL Server to something else,

190
00:11:21,483 --> 00:11:24,466
XML is one of the good formats to use.

191
00:11:25,483 --> 00:11:28,466
We get a common ask if we support JSON format, which we don't

192
00:11:28,483 --> 00:11:32,466
do yet. Obviously you can convert XML into JSON and their version

193
00:11:32,483 --> 00:11:33,400
on the client side.

194
00:11:34,483 --> 00:11:38,466
So anyway, at any rate, I'll say, okay, grab me this and for

195
00:11:38,483 --> 00:11:42,466
each row I want to generate an element called product, and I

196
00:11:42,483 --> 00:11:47,450
want the root element, the root called, let's say, products.

197
00:11:49,483 --> 00:11:50,250
So by default

198
00:11:51,483 --> 00:11:56,466
for XML path and... the asterisk in there.

199
00:11:59,283 --> 00:12:02,466
So now you can see I get some XML default back, and this is the

200
00:12:02,483 --> 00:12:05,0
default structure I get back. So this you can see for every row

201
00:12:05,483 --> 00:12:09,466
I get one of those and I get one of the... this root thing generated

202
00:12:09,483 --> 00:12:13,466
as per my... for XML clause. And you can see by default I get

203
00:12:13,483 --> 00:12:18,466
one element, called an element in XML for each column. But I

204
00:12:18,483 --> 00:12:19,350
can call...

205
00:12:20,366 --> 00:12:23,466
name them a bit differently to basically change the format.

206
00:12:23,200 --> 00:12:24,366
So I'll call this one

207
00:12:26,0 --> 00:12:28,333
ID, and the

208
00:12:29,483 --> 00:12:33,466
@ sign means I would like it to be an attribute rather than an element.

209
00:12:34,383 --> 00:12:37,466
And why I use these quotation marks is just because the @ sign

210
00:12:37,483 --> 00:12:42,466
has a meaning in SQL, right? So it's a delimited identifier and

211
00:12:42,483 --> 00:12:46,466
I want the name just like this. Why I make everything lower case

212
00:12:46,166 --> 00:12:49,450
is by definition XML is case sensitive, so for me, at least,

213
00:12:49,483 --> 00:12:51,466
it simplifies if everything is lower case.

214
00:12:51,483 --> 00:12:56,466
And now the XML that I'm getting back looks like this.

215
00:12:56,483 --> 00:12:58,183
Okay? So you can see it's actually...

216
00:12:58,266 --> 00:12:58,433
>> Clean....

217
00:12:58,483 --> 00:13:02,466
>> fairly simple to retrieve an XML document. You can do more

218
00:13:02,233 --> 00:13:04,466
elaborate things with subqueries and create tree structures,

219
00:13:05,483 --> 00:13:09,466
as well, but this kind of gets you started. So now we grab the data.

220
00:13:10,366 --> 00:13:14,400
Now I want to look at what if I want to use this as a way to

221
00:13:14,483 --> 00:13:17,466
insert new data into the table, or update data?

222
00:13:18,483 --> 00:13:23,283
So let's say we're passing this back in through the server and

223
00:13:23,366 --> 00:13:27,466
we actually have a data type called XML. So we'll say, okay,

224
00:13:28,483 --> 00:13:32,466
this, which we support implicit casting to and from string.

225
00:13:33,483 --> 00:13:37,350
So I pass this into the server, and let's add a new product.

226
00:13:37,433 --> 00:13:39,466
And I don't know what ID it's going to get because there isn't

227
00:13:40,483 --> 00:13:44,466
an identity in there, so let me actually just put it in. So 10,000,

228
00:13:44,483 --> 00:13:52,333
100,000 Tobias. Okay. So this is a new one. And let's say we're

229
00:13:52,483 --> 00:13:54,466
going to update this, so we'll add an exclamation mark at the

230
00:13:54,483 --> 00:13:59,283
end of these three. So just seeing now I pass the string through

231
00:13:59,366 --> 00:14:02,466
the server, it parses into an XML structure internally and then

232
00:14:02,483 --> 00:14:04,466
I can go and query it.

233
00:14:04,483 --> 00:14:09,466
So now we're doing the reverse. Before I generated XML from our

234
00:14:09,483 --> 00:14:14,400
results at going from tabular to XML. Now I'm going doing the reverse.

235
00:14:14,483 --> 00:14:19,466
So I'll do select star from my XML variable, and it has a few

236
00:14:19,483 --> 00:14:22,466
methods to it, and nodes is one of the interesting ones. So basically,

237
00:14:23,333 --> 00:14:26,466
say, hey, go and look for this X

238
00:14:28,483 --> 00:14:34,466
path expression, which is kind of like select against the...

239
00:14:34,483 --> 00:14:38,466
from a where clause made basically against an XML structure.

240
00:14:39,333 --> 00:14:43,466
So basically this says for each product found on the product,

241
00:14:43,483 --> 00:14:48,466
give me a row back. And we'll call this XT as... the set is

242
00:14:48,483 --> 00:14:51,466
called XT and it will return one column which includes the XML

243
00:14:51,483 --> 00:14:55,466
element which I will call XC, so the column. So now I can say,

244
00:14:55,483 --> 00:14:57,466
okay, XT.XC.value,

245
00:14:59,483 --> 00:15:03,466
and I can use this to go into the product element and grab things.

246
00:15:03,483 --> 00:15:07,466
So I'll go and say, well, I would like to grab the ID attribute

247
00:15:08,483 --> 00:15:12,466
and I would like you to grab this as an integer, and I'll call

248
00:15:12,483 --> 00:15:13,466
this product ID.

249
00:15:15,483 --> 00:15:17,383
And I would also like you to go into the

250
00:15:18,483 --> 00:15:21,466
element and grab me the name attribute and return this as...

251
00:15:21,483 --> 00:15:23,466
I don't know, NVARCHAR1000,

252
00:15:24,483 --> 00:15:25,466
let's say,

253
00:15:26,483 --> 00:15:27,433
as name.

254
00:15:28,483 --> 00:15:33,466
So let's just go ahead and execute this and go ahead and just

255
00:15:33,483 --> 00:15:39,466
comment out what I have above here. Okay. So again, I pass

256
00:15:39,483 --> 00:15:43,366
in the structure. I say grab me each product element from products

257
00:15:43,450 --> 00:15:44,233
and return this.

258
00:15:44,483 --> 00:15:45,466
Ah, okay. Nice.

259
00:15:45,483 --> 00:15:46,250
>> Nice.

260
00:15:46,333 --> 00:15:49,466
>> I can now parse this XML nicely. And now I have a set.

261
00:15:50,483 --> 00:15:53,466
So now, hmm, what if I could use the merge statement to actually

262
00:15:53,483 --> 00:15:57,466
merge this data from the XML structure into the table. So I'll

263
00:15:57,483 --> 00:15:59,166
say merge into

264
00:16:00,483 --> 00:16:05,466
products, I guess the table was called ask this is the destination, right?

265
00:16:05,483 --> 00:16:06,466
>> Yeah.

266
00:16:06,483 --> 00:16:11,166
>> Using my XML variable, and now I would have to paste this whole

267
00:16:11,483 --> 00:16:13,466
thing in there, but since we know about common table expressions,

268
00:16:13,483 --> 00:16:17,466
I could just say, well, let's call this one source.

269
00:16:17,483 --> 00:16:19,466
>> Or a source.

270
00:16:20,483 --> 00:16:23,466
>> So now I have a common table expression called SRC. So I would

271
00:16:24,0 --> 00:16:25,466
say using SRC,

272
00:16:26,483 --> 00:16:31,300
so now I'm joining the table with my XML document on SRC.product

273
00:16:31,483 --> 00:16:36,466
ID equals destination product ID.

274
00:16:37,483 --> 00:16:40,466
And then I can start using these various events that we will

275
00:16:40,483 --> 00:16:43,466
go through in the merge statement. So basically I can say when

276
00:16:46,333 --> 00:16:49,233
I think it's not matched, so if

277
00:16:50,483 --> 00:16:54,466
the product ID is not found in the destination, then I would

278
00:16:54,483 --> 00:16:58,466
like to insert, obviously. So I'll say go ahead and insert into

279
00:16:58,483 --> 00:17:01,466
obviously the destination, so I don't say anything other than

280
00:17:01,483 --> 00:17:10,466
that column name, so product ID and name, the values, destination.product ID...

281
00:17:10,483 --> 00:17:12,466
or sorry... source product ID,

282
00:17:14,383 --> 00:17:18,466
comma, source name. Okay. So when it doesn't find it, it inserts,

283
00:17:18,483 --> 00:17:22,466
and then when matched, I would like it to update.

284
00:17:22,483 --> 00:17:27,466
So update the source set and product ID obviously can't change.

285
00:17:27,483 --> 00:17:33,366
So set name equal to source product ID. And obviously I have...

286
00:17:33,450 --> 00:17:36,466
no, that seems correct. Okay. Let's see if this works.

287
00:17:38,266 --> 00:17:39,366
Oh, it is an identity.

288
00:17:39,450 --> 00:17:39,466
>> Yes.

289
00:17:39,483 --> 00:17:44,466
>> It is an identity column. Ah-ha. There we go. There we go.

290
00:17:44,483 --> 00:17:46,466
Let's just not include the product ID then.

291
00:17:47,483 --> 00:17:50,0
And let's not include it up in the XML either,

292
00:17:51,483 --> 00:18:02,333
and there we go. So now it actually added these and we can go

293
00:18:02,416 --> 00:18:07,333
and select, run the select statement from the table again for

294
00:18:07,416 --> 00:18:15,466
the XML, to grab the XML and I'll say like A or name like Tobias.

295
00:18:15,483 --> 00:18:20,166
TOB, so we get that row, as well.

296
00:18:22,483 --> 00:18:25,466
And now you can see that the exclamation marks are in there and

297
00:18:25,483 --> 00:18:26,466
Tobias was added.

298
00:18:27,483 --> 00:18:31,333
The final thing I wanted to show, which gets it a bit extra interesting,

299
00:18:31,483 --> 00:18:37,466
is we'll get... let's get the correct Tobias value in there.

300
00:18:38,483 --> 00:18:40,466
So I got 1,000. Okay.

301
00:18:40,483 --> 00:18:45,416
Cool. So ID equals 1,000.

302
00:18:46,0 --> 00:18:49,466
Let's say I wanted to delete, as well. So let's say, okay, I

303
00:18:49,483 --> 00:18:53,466
want to delete this AW see logo cap. How would I do this?

304
00:18:53,483 --> 00:18:56,466
We have something support where you can say when not matched

305
00:18:56,483 --> 00:18:59,466
in source. That's very dangerous because that means if it's not

306
00:19:00,0 --> 00:19:01,466
in this set, then remove it.

307
00:19:01,483 --> 00:19:02,466
>> Yeah.

308
00:19:02,483 --> 00:19:04,466
>> Which obviously then would remove all our products. So what

309
00:19:04,483 --> 00:19:08,466
I could do instead is I can add another attribute and say, call

310
00:19:10,483 --> 00:19:14,466
it delete and I'll say delete equals true. So I would like to

311
00:19:14,483 --> 00:19:15,466
delete this one.

312
00:19:16,483 --> 00:19:19,233
We'll say we'll grab that from the XML document, as well.

313
00:19:19,316 --> 00:19:22,466
I'll say, well, grab the delete field as a bit

314
00:19:23,483 --> 00:19:27,466
and I'll call it do delete, test delete, or insert keyword.

315
00:19:27,483 --> 00:19:30,416
So now I'm grabbing if it should be deleted or not, and I can

316
00:19:30,483 --> 00:19:33,466
just say if it's not found, obviously will return null. So I'll

317
00:19:33,483 --> 00:19:36,466
just say okay, if it doesn't... if it returns null, then we'll

318
00:19:36,483 --> 00:19:38,466
say false, right?

319
00:19:39,483 --> 00:19:40,466
And do delete.

320
00:19:41,250 --> 00:19:47,183
And now I can say when matched, then this. When not matched, then...

321
00:19:47,483 --> 00:19:53,0
sorry, when matched, and do delete equals one,

322
00:19:56,483 --> 00:20:02,466
then delete, right? So I can actually have more complex expressions

323
00:20:02,483 --> 00:20:06,466
in the one clause rather than just say matched or not matched.

324
00:20:06,483 --> 00:20:10,450
Obviously the other one has to be the opposite, right? So we

325
00:20:10,483 --> 00:20:14,466
should say here, well, if it's zero, then don't...

326
00:20:15,350 --> 00:20:19,466
then update. So we'll go ahead and try and execute this.

327
00:20:20,483 --> 00:20:24,466
Seems to work, right? So again, not watched, insert. Not matched

328
00:20:25,483 --> 00:20:28,466
and do delete false update, or match, then do delete false update,

329
00:20:28,483 --> 00:20:32,166
and then matched and do delete one, then delete. And now if

330
00:20:32,250 --> 00:20:32,466
we query,

331
00:20:34,483 --> 00:20:35,466
you can see that the row was deleted.

332
00:20:35,483 --> 00:20:36,233
>> Yeah.

333
00:20:36,316 --> 00:20:36,466
Nice.

334
00:20:37,483 --> 00:20:40,466
>> So then you've got a bit of an entry in what you can do with

335
00:20:40,483 --> 00:20:42,466
XML and SQL Server 2012, as well.

336
00:20:44,316 --> 00:20:48,466
>> Very nice. Now, there are other ways that we can delete content

337
00:20:48,483 --> 00:20:50,466
that's probably not quite as complicated as writing... if you're

338
00:20:50,483 --> 00:20:55,466
not in the need for XML, we can use the delete statement. I know

339
00:20:55,166 --> 00:20:57,466
it wasn't... it's not as fun and cool as what Tobias just did,

340
00:20:57,483 --> 00:21:01,466
but we could just do a delete from the table and, again, very

341
00:21:01,483 --> 00:21:04,466
critical, just like the update clause. If you don't have a where

342
00:21:04,483 --> 00:21:06,466
clause, if I did a delete from Production.UnitMeasure, what am

343
00:21:06,483 --> 00:21:09,466
I going to delete without a where clause? What's going to be deleted?

344
00:21:10,483 --> 00:21:13,250
You got it. Everything. So we want to be clarify about that.

345
00:21:13,333 --> 00:21:15,466
Pretty much whenever you use an update and a delete, you're going

346
00:21:15,483 --> 00:21:19,466
to want to use a where clause just because you want to avoid

347
00:21:19,483 --> 00:21:22,466
what I call RPEs, resume producing events. So you want to make

348
00:21:22,483 --> 00:21:25,466
sure you don't get... have to generate a new resume because you

349
00:21:25,483 --> 00:21:30,283
deleted 40,000 rows of really value information. So delete from

350
00:21:30,366 --> 00:21:34,466
whatever the table is where unit measure equal and specify the

351
00:21:34,483 --> 00:21:39,466
criteria that you want to meet in order for that row to be deleted.

352
00:21:39,233 --> 00:21:42,466
Now, you may want to delete everything from a table. Now, one

353
00:21:42,483 --> 00:21:45,466
way to do that is use this delete clause statement without a

354
00:21:45,216 --> 00:21:47,466
where clause. Another way to do this... but if you do it this

355
00:21:47,483 --> 00:21:50,466
way, by the way, this is logged in your transaction log. If you

356
00:21:50,483 --> 00:21:54,300
use the truncate table to remove all data, we're going to truncate

357
00:21:54,383 --> 00:21:56,466
the table. That means pretty much don't delete the table, but

358
00:21:56,483 --> 00:21:59,466
take all of the data out of table. All right? And the good thing

359
00:22:00,483 --> 00:22:02,466
about this, it's not going to write every row to the...

360
00:22:02,483 --> 00:22:05,400
there's minimal logging for the information that's being written

361
00:22:05,483 --> 00:22:07,466
to the transaction log, so it will go much faster if you have

362
00:22:08,483 --> 00:22:12,466
40, 50, 60, 70,000 rows in there, it will be a little bit faster

363
00:22:12,166 --> 00:22:14,466
for you to be able to delete that.

364
00:22:14,483 --> 00:22:16,433
>> Especially let's say, you have...

365
00:22:16,450 --> 00:22:16,466
>> A million....

366
00:22:16,483 --> 00:22:17,466
>> 5 billion rows.

367
00:22:17,483 --> 00:22:18,466
>> Yeah. A billion rows.

368
00:22:18,483 --> 00:22:20,466
>> Definitely there will be a huge difference.

369
00:22:22,333 --> 00:22:24,466
>> Aren't you supposed to go $5 billion or...

370
00:22:25,416 --> 00:22:29,283
yeah. You probably don't know. What was that show?

371
00:22:30,166 --> 00:22:31,216
>> Austin Powers.

372
00:22:31,300 --> 00:22:31,466
>> Austin Powers.

373
00:22:31,483 --> 00:22:33,466
>> I thought you were referencing Swedish shows.

374
00:22:33,483 --> 00:22:37,466
>> Yeah, yeah. All right. So we did inserts, updates, deletes

375
00:22:37,183 --> 00:22:39,466
with XML, just trying to see if there's anything here.

376
00:22:41,483 --> 00:22:43,466
No, I think you got the cool stuff, especially with that merge.

377
00:22:44,483 --> 00:22:45,183
So that's good.

378
00:22:45,483 --> 00:22:47,466
Constraints and triggers. One of the things... so we looked

379
00:22:47,483 --> 00:22:51,466
at adding content and making sure that we can add content several

380
00:22:51,483 --> 00:22:54,466
different ways. Update the content, deleting the content.

381
00:22:54,483 --> 00:22:56,466
But one of the things we need to be concerned about, as well,

382
00:22:56,483 --> 00:23:00,266
is data integrity. So what we can use when we're adding content

383
00:23:00,350 --> 00:23:03,466
are constraints and triggers. And what they can do for us is

384
00:23:03,483 --> 00:23:07,466
to make sure that what we're adding is appropriate or valid,

385
00:23:07,483 --> 00:23:10,466
and we can also make sure that if we're adding content or updating

386
00:23:10,483 --> 00:23:14,350
content, that if there are other tables that need to be updated

387
00:23:14,433 --> 00:23:18,466
as well, we can make sure those are updated. So we can create

388
00:23:18,483 --> 00:23:20,466
four, five different types of constraints. We'll introduce each

389
00:23:20,483 --> 00:23:23,466
one of those. And we can also use, implement what are called triggers.

390
00:23:23,483 --> 00:23:27,466
So I could have an update trigger on the employee table. So on

391
00:23:27,483 --> 00:23:31,466
the employee table, if I update the last name there, I'm going

392
00:23:31,483 --> 00:23:34,466
to fire a trigger that's going to go out and also update the

393
00:23:34,483 --> 00:23:37,466
accounts payable table or the accounts receivable or payroll table.

394
00:23:37,483 --> 00:23:41,466
So anywhere that last name resides in my database, I can have

395
00:23:41,483 --> 00:23:44,466
it go out using a trigger and update every column that needs

396
00:23:44,483 --> 00:23:47,466
to be updated for that last name. So that's the idea of a DML

397
00:23:47,483 --> 00:23:51,466
trigger where I'm doing data manipulation and I'm going to use triggers.

398
00:23:51,483 --> 00:23:54,466
Let's talk about our constraints. We have a primary key constraint.

399
00:23:55,400 --> 00:23:57,466
This is very, very important when you're designing your database

400
00:23:57,483 --> 00:24:01,466
and your rows, your tables within the database. What this does

401
00:24:01,483 --> 00:24:05,166
for you is it ensures that you have uniqueness on that table.

402
00:24:05,250 --> 00:24:07,466
Pretty much every table you're going use in relational database

403
00:24:07,483 --> 00:24:10,283
will have a primary key on it, and that primary key is going

404
00:24:10,366 --> 00:24:12,466
to enforce uniqueness. Now, one of the chats came in earlier

405
00:24:12,483 --> 00:24:16,366
was like, well, does the primary key have to be a composite key

406
00:24:16,450 --> 00:24:20,466
or can a composite key be a primary key? A composite key is a

407
00:24:20,483 --> 00:24:24,416
key that contains two or more columns. So absolutely a primary

408
00:24:24,483 --> 00:24:27,466
key can be a composite key, a foreign key can be a composite

409
00:24:27,483 --> 00:24:31,466
key, a unique constraint could be a composite key. So a composite

410
00:24:31,483 --> 00:24:35,400
key is just multiple columns are required to make that unique.

411
00:24:35,483 --> 00:24:37,466
Let's say, for instance, I'm a driver's license. My driver's

412
00:24:37,483 --> 00:24:43,466
license number is 1234, and I'm from Arizona. Now, Tobias also

413
00:24:43,483 --> 00:24:47,466
has a driver's license and he's 1234 and he's from Washington.

414
00:24:47,183 --> 00:24:50,466
Well, if we put those in the same table, I can't enforce uniqueness

415
00:24:50,483 --> 00:24:53,466
because if we have just the primary key on the driver's license

416
00:24:53,483 --> 00:24:57,450
number for 1234, the first one in is going to win. The second

417
00:24:57,483 --> 00:25:00,200
one is... sorry, we aren't able to 1234, we can't play.

418
00:25:00,283 --> 00:25:00,466
>> And I'll be first in.

419
00:25:00,483 --> 00:25:01,466
>> You don't get a driver's license.

420
00:25:01,483 --> 00:25:03,216
>> No, I'll be first.

421
00:25:03,483 --> 00:25:07,466
>> So what we'll do is we'll actually create a composite primary key.

422
00:25:07,183 --> 00:25:11,466
So we're going to take 1234 and we're going to concatenate on

423
00:25:11,166 --> 00:25:15,333
WA for Washington, and we're going to take my 1234 concatenate AZ.

424
00:25:15,416 --> 00:25:18,466
We'll make that a composite primary key. Now they're unique.

425
00:25:18,483 --> 00:25:21,466
Now they're going to use the columns together to enforce the uniqueness.

426
00:25:21,483 --> 00:25:24,466
Now we can work together. Now we can both be in that database.

427
00:25:24,483 --> 00:25:27,466
AZ is alphabetical before WA, unless they do it in descending

428
00:25:27,483 --> 00:25:30,466
order, so I should win anyway, but that's a side note.

429
00:25:31,333 --> 00:25:32,333
[Laughter]

430
00:25:32,483 --> 00:25:35,466
First one in wins. So what we can do is we can add a primary

431
00:25:35,483 --> 00:25:39,466
key to a table. It can be composite. It requires you... it enforces

432
00:25:39,483 --> 00:25:43,466
uniqueness for us, and pretty much most tables are going to have

433
00:25:43,483 --> 00:25:47,466
that primary key to enforce uniqueness for the values that are

434
00:25:47,483 --> 00:25:50,466
stored or the rows that are stored in that database or in that table.

435
00:25:51,483 --> 00:25:53,466
Now, in addition to that, we have what's called a foreign key.

436
00:25:53,483 --> 00:25:57,466
A foreign key can also be a composite key. It's a combination

437
00:25:57,483 --> 00:26:00,466
of one or more columns that's going to allow us to reference

438
00:26:00,483 --> 00:26:04,466
that primary key, okay? So we look at, for instance, if we come

439
00:26:04,483 --> 00:26:07,466
back down here, this is adding one here, alter table or adding

440
00:26:07,483 --> 00:26:11,283
a constraint called a foreign key. I like to use the prefix

441
00:26:11,366 --> 00:26:13,466
of the type of key at the beginning. So we have primary key,

442
00:26:13,483 --> 00:26:16,383
we have foreign key, we have a couple more coming up, but I like

443
00:26:16,466 --> 00:26:19,466
to put that at the beginning so I know what type of key I'm working with.

444
00:26:19,483 --> 00:26:22,466
It's a foreign key. It's going to reference this table called

445
00:26:22,483 --> 00:26:25,466
sales reason, and it's going to reference the column over there

446
00:26:25,483 --> 00:26:28,466
called sales reason ID. And we're also going to talk about what

447
00:26:28,483 --> 00:26:31,466
happens if we try to delete that, what happens if we try to update that.

448
00:26:31,483 --> 00:26:34,466
We want to cascade that delete or that update, all right?

449
00:26:34,483 --> 00:26:37,466
So we want to make sure that that delete takes place. If it

450
00:26:37,483 --> 00:26:41,466
does take place, it gets cascaded. So alter table or foreign

451
00:26:41,483 --> 00:26:46,383
key is used to reference, normally a primary key could be a unique

452
00:26:46,466 --> 00:26:49,383
constraint, which we're going to introduce next on another table.

453
00:26:49,466 --> 00:26:52,383
So if I'm going in and I'm adding a new product and one of the product...

454
00:26:52,466 --> 00:26:56,466
one of the items are in the product is category, well, category

455
00:26:56,483 --> 00:26:58,466
information is not going to be stored in that table. It's going

456
00:26:58,483 --> 00:27:00,466
to be stored in another table called categories. Well, over

457
00:27:01,166 --> 00:27:03,350
in that second table called categories I'm going to have a primary

458
00:27:03,433 --> 00:27:07,216
key and category ID. I'm going to have a foreign key in the products

459
00:27:07,300 --> 00:27:11,216
table that references that primary key in that category table.

460
00:27:11,300 --> 00:27:14,466
And just to make sure that I'm adding valid content, it's going

461
00:27:14,166 --> 00:27:16,466
to reference to make sure is there a category over there called

462
00:27:16,483 --> 00:27:18,466
Froot Loops or something. I have no idea where I got with Froot

463
00:27:18,483 --> 00:27:21,466
Loops, but we'll go with that one. So we'll reference that to

464
00:27:21,483 --> 00:27:24,466
make sure it's valid data that we're adding. Now, I can only

465
00:27:24,483 --> 00:27:28,466
add one primary key per table, but there may be other columns

466
00:27:28,483 --> 00:27:31,466
in a table that I want to enforce uniqueness on. So what I could

467
00:27:31,483 --> 00:27:35,466
do is use a unique constraint, a unique constraint allows me

468
00:27:35,483 --> 00:27:38,466
to enforce uniqueness on columns other than the primary key.

469
00:27:38,483 --> 00:27:41,450
So we're already going to enforce uniqueness with the state code

470
00:27:41,483 --> 00:27:44,200
in the driver's license. Maybe we want to make sure a Social

471
00:27:44,283 --> 00:27:46,433
Security number's going to be in there. We want to make sure

472
00:27:46,483 --> 00:27:49,333
the Social Security number, because that should also be unique,

473
00:27:49,483 --> 00:27:52,233
but my primary key has already been consumed with the driver's

474
00:27:52,316 --> 00:27:55,466
license and the state code. What could create a Social Security...

475
00:27:55,483 --> 00:27:59,466
a unique constraint on that Social Security column to enforce

476
00:27:59,483 --> 00:28:02,466
the uniqueness on that column. So unique constraints are used

477
00:28:02,483 --> 00:28:06,466
to enforce uniqueness on columns within a table if your primary

478
00:28:06,483 --> 00:28:10,466
key is already enforced uniqueness on other tables or other columns

479
00:28:11,483 --> 00:28:15,433
within that table. We can also introduce another type of constraint

480
00:28:15,483 --> 00:28:18,466
called a check constraint. This enforces the type of content

481
00:28:18,483 --> 00:28:21,466
or the values that are being added. This here is an example

482
00:28:21,483 --> 00:28:25,466
of alternate table called new table. We're adding a column called

483
00:28:25,483 --> 00:28:29,466
ZIP code. It's an integer value with null. We're going to create

484
00:28:29,483 --> 00:28:33,400
a constraint on there called check ZIP code, and what we're going

485
00:28:33,483 --> 00:28:35,466
to do is we're going to set this up to check the ZIP code so

486
00:28:35,483 --> 00:28:40,283
when someone enters in the 05648 or whatever the ZIP code is,

487
00:28:40,366 --> 00:28:42,333
it's going to make sure that no one enters 0546P

488
00:28:43,483 --> 00:28:46,466
because this is going to make sure... it can't go out and say,

489
00:28:46,483 --> 00:28:49,416
all right, is this a valid ZIP code without checking everything

490
00:28:49,483 --> 00:28:53,466
in the country, but it can make sure no one let's slip in accidentally,

491
00:28:53,483 --> 00:28:56,466
you know, puts in an alpha character or some type of symbol.

492
00:28:56,483 --> 00:28:58,466
>> And it better be an American ZIP code.

493
00:28:58,483 --> 00:29:00,466
>> And it better be an American ZIP code if we're going to be

494
00:29:00,483 --> 00:29:02,466
doing that. Exactly. Definitely.

495
00:29:02,483 --> 00:29:04,466
>> And probably it shouldn't be an integer. It probably should

496
00:29:04,483 --> 00:29:06,466
be some bar chart...

497
00:29:07,483 --> 00:29:09,466
>> Bar chart, yeah, because nowadays you have the dash and the

498
00:29:09,483 --> 00:29:11,466
three or four other characters...

499
00:29:11,483 --> 00:29:14,466
>> You're using like, and like you use on strings, so...

500
00:29:14,483 --> 00:29:18,466
>> Oh, i gotcha. Exactly. Yeah. So this would enforce that type

501
00:29:18,483 --> 00:29:21,466
of data or the values being added. Make sure that there's not

502
00:29:21,233 --> 00:29:25,466
adding any type of inappropriate content here. The last type

503
00:29:25,483 --> 00:29:26,466
of constraint that we're going to talk about...

504
00:29:26,483 --> 00:29:28,466
>> Do you have examples of inappropriate content?

505
00:29:28,483 --> 00:29:35,466
>> I just said like 0546P, that would be inappropriate for this column.

506
00:29:35,483 --> 00:29:36,466
>> I see. I see.

507
00:29:36,483 --> 00:29:37,466
>> Just for this column.

508
00:29:37,483 --> 00:29:38,466
>> It sounds really inappropriate.

509
00:29:38,483 --> 00:29:39,466
>> It does.

510
00:29:41,483 --> 00:29:42,466
Well, you were jumping... you jumped all over that one like drool

511
00:29:42,483 --> 00:29:43,466
on a baby.

512
00:29:45,483 --> 00:29:47,466
So the next, in the last constraint we're going to talk about

513
00:29:47,483 --> 00:29:50,466
is in default constraint. If there are values that's probably...

514
00:29:51,450 --> 00:29:51,466
going to get picked on by this...

515
00:29:52,166 --> 00:29:52,466
>> Yes.

516
00:29:52,483 --> 00:29:55,466
>> I'm not from Sweden, so. Alter table, we're going to add a

517
00:29:55,483 --> 00:30:00,466
default constraint. The country region code by default is going

518
00:30:00,200 --> 00:30:00,466
to be USA.

519
00:30:01,483 --> 00:30:02,166
All right.

520
00:30:02,483 --> 00:30:04,466
>> Is that actually... I thought it was US, that's the region

521
00:30:04,483 --> 00:30:06,466
code for the US.

522
00:30:06,483 --> 00:30:08,466
>> It could be. I was just... I thought you wanted a reason to

523
00:30:08,483 --> 00:30:11,416
say why does it have to be US, why can't it be Sweden?

524
00:30:11,483 --> 00:30:13,383
What's Sweden's code?

525
00:30:13,450 --> 00:30:13,466
>> SE.

526
00:30:13,483 --> 00:30:19,466
>> SE? Okay. So we could add US or SE as the default... I forgot

527
00:30:19,483 --> 00:30:21,466
I was to be working with him today or I would have made this

528
00:30:21,483 --> 00:30:25,466
SE to make it safe, but, so instead of me having to supply when

529
00:30:25,483 --> 00:30:29,466
I'm doing insert, instead of me having to supply the country

530
00:30:29,166 --> 00:30:33,466
code, it would, by default, if I don't supply SE, for instance,

531
00:30:33,483 --> 00:30:36,466
it would by default populate that with USA. So just makes it

532
00:30:36,483 --> 00:30:39,350
a little bit easier when we're adding content into a table.

533
00:30:39,333 --> 00:30:41,416
[Laughter]

534
00:30:41,433 --> 00:30:43,466
>> All right. So those are the five different types of constraints

535
00:30:43,483 --> 00:30:46,466
that are used for enforcing the type of data being added.

536
00:30:46,483 --> 00:30:49,166
We're trying to make sure the contents being added is not garbage.

537
00:30:49,250 --> 00:30:50,466
>> And we're enforcing it's USA.

538
00:30:50,483 --> 00:30:51,466
>> And we're enforcing it's USA.

539
00:30:51,483 --> 00:30:52,466
>> It's USA.

540
00:30:52,483 --> 00:30:54,466
>> And by the way, we're going to make that table, that columns

541
00:30:54,483 --> 00:30:56,466
so it can't be overridden. It has to be USA.

542
00:30:57,483 --> 00:30:59,466
Or SE. All right.

543
00:31:00,483 --> 00:31:03,466
So those are the idea of constraints that we can use when we're

544
00:31:03,216 --> 00:31:05,466
inserting or updating content. The other idea that we want to

545
00:31:06,0 --> 00:31:09,433
look at are DML triggers, and a trigger, again, is a way for

546
00:31:09,483 --> 00:31:11,466
us that could be as simple as, hey, I'm going to go in there

547
00:31:11,483 --> 00:31:14,466
and create a trigger on a customer table. After someone does

548
00:31:14,483 --> 00:31:17,466
an insert or an update, I just want to send a message. I want

549
00:31:17,483 --> 00:31:21,400
to raise an error pops up or I can use those XP send mail, and

550
00:31:21,483 --> 00:31:25,466
it can send an email to the manager and say, hey, a new customer's

551
00:31:25,483 --> 00:31:30,0
added to this table. We could use it for an XML, a trigger for that.

552
00:31:30,483 --> 00:31:33,250
We could use a trigger for making sure the data stays consistent.

553
00:31:33,333 --> 00:31:36,400
And so we go in and we have a trigger on the last name column

554
00:31:36,483 --> 00:31:38,466
of the employee table, and that trigger is ever if there's an

555
00:31:39,166 --> 00:31:43,466
update on that column in that table, I want a trigger so it goes

556
00:31:43,483 --> 00:31:48,466
out to accounts payable or it goes out to payroll, and also changes

557
00:31:48,483 --> 00:31:51,466
the last name in that table and it goes to any other table that

558
00:31:51,483 --> 00:31:55,216
contains the last name. So you can also have a trigger that's

559
00:31:55,300 --> 00:31:59,466
assigned to one table that will trip or fire and that will cause

560
00:31:59,483 --> 00:32:01,466
an update to take place on any other table.

561
00:32:01,483 --> 00:32:05,466
>> And there's a few things to kind of mention here, as well.

562
00:32:06,0 --> 00:32:07,466
One thing I just want to mention... we'll get into it a bit

563
00:32:08,0 --> 00:32:12,466
later in the class... but you probably want to use the throw

564
00:32:12,483 --> 00:32:15,466
statement, which is new to SQL Server 2012, rather than the raise

565
00:32:17,233 --> 00:32:21,0
error statement that we have down here. We'll talk a bit more

566
00:32:21,483 --> 00:32:23,466
about that later. But the other thing that's worth noting about

567
00:32:23,483 --> 00:32:27,466
triggers is the most common uses for triggers is really...

568
00:32:27,183 --> 00:32:32,466
one is, just like Brian mentioned, to validate some sort of...

569
00:32:32,483 --> 00:32:36,466
more complex integrity that you can't figure out with check constraints,

570
00:32:36,166 --> 00:32:37,216
foreign keys and so on,

571
00:32:38,483 --> 00:32:41,200
Which is typically a good idea.

572
00:32:41,283 --> 00:32:44,466
And obviously the more triggers you add, the more complexity

573
00:32:44,483 --> 00:32:47,366
you have and there can be performance implications.

574
00:32:47,483 --> 00:32:50,466
The other thing that is also very common is to update denormalized

575
00:32:51,333 --> 00:32:54,333
data, so you have things normalized first nicely and there are

576
00:32:54,483 --> 00:32:56,466
no duplicates anywhere, but then a common thing when you get

577
00:32:57,483 --> 00:33:00,466
into performance issues is, ah, maybe I'll have this column here,

578
00:33:00,483 --> 00:33:03,466
as well, and then I don't need to draw in these six tables to

579
00:33:03,483 --> 00:33:07,466
get this result set. And then it's fairly common to use triggers

580
00:33:07,483 --> 00:33:10,466
to go and actually update this other column when things happen,

581
00:33:10,483 --> 00:33:13,466
and that can get you into trouble if there is a lot of updates

582
00:33:13,483 --> 00:33:17,466
or inserts or whatever you're triggering on. So it's worth considering

583
00:33:17,483 --> 00:33:20,466
does it always have to be absolutely up to date. If the answer

584
00:33:20,483 --> 00:33:24,466
is no, you're probably better off having something like a job

585
00:33:24,233 --> 00:33:28,466
that runs on some schedule and updates these changes.

586
00:33:31,483 --> 00:33:33,466
>> All right. Good information. The last piece we want to look

587
00:33:33,483 --> 00:33:36,466
at is the output clause which is used to return information from

588
00:33:37,166 --> 00:33:41,466
any type of expression or whenever we're performing an insert

589
00:33:41,483 --> 00:33:44,333
update or delete. Here's an example of how we would create that.

590
00:33:45,483 --> 00:33:49,466
Notice in here we've got delete sales shopping cart item output deleted.asterisk.

591
00:33:49,483 --> 00:33:52,466
That output deleted.asterisk specifies that all columns in the

592
00:33:52,483 --> 00:33:56,466
deleted rows, we're going to be returned to the application that

593
00:33:56,483 --> 00:33:59,466
called that delete. So in this case here it might be just query

594
00:33:59,183 --> 00:34:01,466
editor that's calling that delete. And then what we'll do is

595
00:34:01,483 --> 00:34:03,466
we'll verify in the rows our match with the where clause have

596
00:34:03,483 --> 00:34:06,466
been deleted. We'll go back afterwards. So we're going to delete

597
00:34:06,483 --> 00:34:10,466
sales.shopping cart item output deleted.asterisk where shopping

598
00:34:10,483 --> 00:34:14,466
cart ID equals 20621, and then we'll verify that that item was deleted.

599
00:34:14,483 --> 00:34:16,466
>> Brian, Brian, Brian, can I show them a demo?

600
00:34:16,483 --> 00:34:18,466
>> You... I would love for to you show them a demo.

601
00:34:18,483 --> 00:34:22,466
>> Oh. Thank you. So actually, this output clause...

602
00:34:22,483 --> 00:34:24,316
>> Is this going to be in Swedish or English?

603
00:34:24,450 --> 00:34:24,466
>> Oh, Swedish.

604
00:34:25,166 --> 00:34:27,466
Oop. Now, output clause...

605
00:34:29,483 --> 00:34:31,466
let's stay with English.

606
00:34:31,166 --> 00:34:31,466
>> All right. Thanks.

607
00:34:31,483 --> 00:34:35,466
>> So the update or this output clause is super useful. It falls

608
00:34:35,483 --> 00:34:38,466
into, you know, a bit of the same bucket as this Window functions

609
00:34:38,483 --> 00:34:43,466
that are kind of magical. This is not probably as high of a bar

610
00:34:43,483 --> 00:34:47,466
to get into. It's fairly easy to use, but it's super, super useful.

611
00:34:47,166 --> 00:34:52,466
So just the common example is really I update, let's just say,

612
00:34:52,483 --> 00:34:59,466
production, the product table and I want to set the name column

613
00:35:00,166 --> 00:35:03,183
into uppercase, let's say. So I'll just say upper name.

614
00:35:04,266 --> 00:35:10,466
And after I do this, I want to go and do something else with

615
00:35:10,483 --> 00:35:13,466
these particular products. You can easily get into a problem here.

616
00:35:13,483 --> 00:35:17,400
Let's say I have a where clause here and say where list price

617
00:35:17,483 --> 00:35:21,466
is greater than ten, right? Let's say this is a transaction.

618
00:35:21,483 --> 00:35:24,466
I will get into transactions later, but let's say I update first,

619
00:35:25,483 --> 00:35:28,200
and now after I want to go and do something else with exactly

620
00:35:28,283 --> 00:35:31,466
these products, right, that I updated? So first we increase the

621
00:35:32,166 --> 00:35:34,366
price, and then we'll go and do some other things with other

622
00:35:34,483 --> 00:35:38,466
tables related to these products. A problem is that if I just

623
00:35:38,483 --> 00:35:42,466
use the same where clause, if someone else inserted rows after

624
00:35:42,483 --> 00:35:45,466
my update that matched the where clause, right?... where list

625
00:35:45,483 --> 00:35:49,366
price is greater than ten, my update may affect ten rows.

626
00:35:49,450 --> 00:35:52,0
Someone else insert the 11th row, so the next statement that

627
00:35:52,483 --> 00:35:55,466
goes and does something updates now or manages 11 rows.

628
00:35:55,483 --> 00:35:56,233
>> Uh-huh.

629
00:35:56,316 --> 00:35:58,466
>> Okay? That's called inconsistent analysis, and

630
00:36:01,483 --> 00:36:05,466
you need to have a different type of locking in place to protect

631
00:36:05,483 --> 00:36:08,350
yourself against them. But the update clause or the output clause

632
00:36:08,433 --> 00:36:11,466
can really help you here. So what I can do is...

633
00:36:12,383 --> 00:36:14,466
or that's called phantom row, sorry.

634
00:36:15,483 --> 00:36:21,450
Not inconsistent analysis. So I can say, hey, output the product

635
00:36:21,483 --> 00:36:26,466
ID of all of these rows, and you can say into like a table variable

636
00:36:27,0 --> 00:36:33,466
or something, but let's just do this. Oh. Sorry. And output

637
00:36:33,483 --> 00:36:37,166
insert.product ID. So in an update inserted will refer to the

638
00:36:37,250 --> 00:36:39,466
new value, and obviously I didn't change product ID, and deleted

639
00:36:39,483 --> 00:36:43,466
will refer to the old value. So if I do this, now I can see,

640
00:36:43,483 --> 00:36:48,466
ah, 291 rows returned, and those are exactly the products that

641
00:36:48,166 --> 00:36:48,466
I updated.

642
00:36:49,483 --> 00:36:52,400
So what I can now is do obviously on the client side if I just

643
00:36:52,483 --> 00:36:56,183
return this, I know I upped it exactly these products.

644
00:36:56,483 --> 00:36:59,466
The other thing I could do is I can say, oh, I'll have a table

645
00:36:59,483 --> 00:37:03,216
variable that contains

646
00:37:06,483 --> 00:37:08,466
this product ID column,

647
00:37:14,250 --> 00:37:20,466
and I can now go and do into that product ID or that table variable,

648
00:37:21,483 --> 00:37:25,266
and now exactly these product IDs are in there, so then later

649
00:37:25,350 --> 00:37:29,466
in your queries you can now start joining with this table variable

650
00:37:29,483 --> 00:37:34,466
and it will contain exactly those columns that you... or those

651
00:37:34,483 --> 00:37:37,466
rows that you updated. So now you don't need to worry about problems

652
00:37:38,0 --> 00:37:41,466
such as phantom rows, and you don't need to increase the locking

653
00:37:41,483 --> 00:37:46,216
and the transaction isolation level which could basically decrease

654
00:37:46,483 --> 00:37:48,466
your chances of having good concurrency.

655
00:37:50,400 --> 00:37:50,466
>> All right.

656
00:37:50,483 --> 00:37:54,233
Outstanding. So we're going to wrap this up. Just we walked

657
00:37:54,316 --> 00:37:57,466
through some of the DML statements unlike what it said in the

658
00:37:57,483 --> 00:38:01,466
front, DML statements, and these included the insert, updates, deletes.

659
00:38:01,483 --> 00:38:04,466
We showed you different ways for inserting content, specifically

660
00:38:04,483 --> 00:38:08,466
with the insert into statement, the select statement, the exec statement.

661
00:38:08,483 --> 00:38:09,466
We talked about select into.

662
00:38:10,483 --> 00:38:13,466
We also told you how we could use update or merge. We've got

663
00:38:13,166 --> 00:38:15,466
a demo on how to use a merge for updating content.

664
00:38:15,483 --> 00:38:19,233
Different ways for us to remove data include the delete statement

665
00:38:19,316 --> 00:38:22,466
or truncate table statement, which can be used to delete the

666
00:38:23,166 --> 00:38:25,466
content or either a row, or if you want to delete everything

667
00:38:25,483 --> 00:38:28,466
in a table, just use a delete without a where clause or use the

668
00:38:29,0 --> 00:38:32,466
truncate table option. We talked about the identity property

669
00:38:32,233 --> 00:38:35,466
versus the sequence property. Sequence is new in 2010... or 12,

670
00:38:35,483 --> 00:38:38,466
and what this will do for us is it's more of a database level

671
00:38:38,483 --> 00:38:42,450
sequence or column that it can use, and I still have the seed

672
00:38:42,483 --> 00:38:45,466
in increment values I can set versus the identity property that's

673
00:38:45,483 --> 00:38:47,333
been around for a while. That's more of a table.

674
00:38:47,483 --> 00:38:50,466
But again, I can supply this seed in increment value for that.

675
00:38:50,483 --> 00:38:53,466
We talked about the five different types of constraints that

676
00:38:53,483 --> 00:38:56,466
we can use: The primary key, the foreign key, the unique, the

677
00:38:56,483 --> 00:38:59,466
check, and the default constraint. And then we also talked about

678
00:38:59,483 --> 00:39:05,466
the use of DML triggers, and as Tobias pointed out, we specify

679
00:39:05,483 --> 00:39:08,466
the use of raise error. Later on we're going to use the throw.

680
00:39:08,483 --> 00:39:11,383
We're going to talk about how that would be a little more beneficial.

681
00:39:11,466 --> 00:39:13,466
So let's take about a ten-minute stretch and we're going to take...

682
00:39:13,483 --> 00:39:17,466
come back here. We'll continue our discussion into the next module

683
00:39:17,483 --> 00:39:19,466
where we're going to talk about some programming elements, some

684
00:39:19,483 --> 00:39:23,466
error handling, and that's where we're going to introduce items

685
00:39:23,483 --> 00:39:27,466
like the throw and catch. So we'll see you back here in about

686
00:39:27,483 --> 00:39:29,316
ten minutes. Enjoy the break.

